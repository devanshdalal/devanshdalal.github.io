<!DOCTYPE HTML>
<!--
    Editorial by HTML5 UP
    html5up.net | @ajlkn
    Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
  <title>Joshua Morton</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <!--[if lte IE 8]><script src="https://joshuamorton.github.io/assets/js/ie/html5shiv.js"></script><![endif]-->
  <link rel="stylesheet" href="../../assets/css/main.css" />
  <link rel="stylesheet" href="../../assets/css/custom.css" />
  <link rel="stylesheet" href="../../assets/css/highlight.css" />
  <!--[if lte IE 9]><link rel="stylesheet" href="https://joshuamorton.github.io/assets/css/ie9.css" /><![endif]-->
  <!--[if lte IE 8]><link rel="stylesheet" href="https://joshuamorton.github.io/assets/css/ie8.css" /><![endif]-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.4.3/d3.min.js",
type="text/javascript"></script>
</head>


<body>

    <!-- Wrapper -->
    <div id="wrapper">

        <!-- Main -->
        <div id="main">
            <div class="inner">

                <!-- Header -->
  <header id="header">
    <a href="../../index.html" class="logo"><strong>Joshua Morton</strong> portfolio and blog</a>
    <ul class="icons">
      
      <li><a href="https://twitter.com/joshthejuggles" class="icon fa-twitter" target="_blank"><span class="label">Twitter</span></a></li>
      
      
      
      
      
      
      
      
      <li><a href="https://github.com/joshuamorton" class="icon fa-github" target="_blank"><span class="label">GitHub</span></a></li>
      
      
      
      <li><a href="https://www.linkedin.com/in/joshuamorton13" class="icon fa-linkedin" target="_blank"><span class="label">LinkedIn</span></a></li>
      
    </ul>
  </header>


                <!-- Content -->
                <section>

                  

                <div class="inner">
  
  <section>
    <h1 class="post-title">
      <a href="../../2015/09/27/decorators/index.html">
        Decorators
      </a>
    </h1>

    <span class="post-date">27 Sep 2015</span>

    <p>Let’s start off easy. This will be both an introduction to this blog’s style and
an introduction to a cool tool that every python programmer should know. I’m a
huge fan of literate programming and all that, so this blog post will be
available in two forms, a markdown form like this, as well as an inverted form,
a runnable python file with the code and the commentary in comments. I’m writing
this post with python 3 in mind (and generally I use python 3), but for this
post specifically, there shouldn’t be any python 2 incompatibilities.</p>

<p>With that disclaimer, let’s get started. Python has functions. Functions are
great tools for doing things. Decorators allow a programmer to modify the way
functions work, which can be extremely powerful. That said, both the syntax and
ideas can be rather mind-bending, especially the more complex examples. <a href="http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/">This is
nothing
new</a>,
and there are a lot of good resources out there to learn how decorators work, I
just think mine is better.</p>

<p>So python can have functions</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>  <span class="c"># adds one</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre>
</div>
<p>Functions can obviously be vastly more complex than something that simply
increments a value, but this will already get confusing, so we start simple.<br />
We also want to verify that our function actually <em>works</em>.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">assert</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>  <span class="c"># True</span>
</code></pre>
</div>
<p>Functions can call other functions within them, mathematically speaking, this
would be “function composition”.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>  <span class="c"># adds two</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">assert</span> <span class="n">g</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>  <span class="c"># True</span>
</code></pre>
</div>

<p>Importantly, functions are just data that we can pass into another function. A
function can take another function as an argument. At first this seems a little
silly, but it can be useful.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="c"># if you aren't familiar with this, don't worry, Callable just means that you</span>
<span class="c"># can treat the object like a function, and Iterable means that you can loop</span>
<span class="c"># over the object</span>

<span class="k">def</span> <span class="nf">apply_function</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>  <span class="c"># this just calls the function on the argument</span>


<span class="k">def</span> <span class="nf">my_map</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
    <span class="n">new_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
        <span class="n">new_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">new_list</span>


<span class="k">assert</span> <span class="n">apply_function</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
<span class="k">assert</span> <span class="n">my_map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</code></pre>
</div>

<p>The act of iterating over a list and applying a function to each member is so
common that python provides a builtin to do just that (the map function),
although often list comprehensions (<code class="highlighter-rouge">[f(item) for item in l]</code>) are the more
“pythonic” solution.</p>

<p>The next, and arguably hardest cognitive leap is that functions can return
functions. That is, we can create a function within another function.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">function_builder</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">child_function</span><span class="p">():</span>
        <span class="k">return</span> <span class="s">"hello world"</span>
    <span class="k">return</span> <span class="n">child_function</span>

<span class="k">assert</span> <span class="n">function_builder</span><span class="p">()()</span> <span class="o">==</span> <span class="s">"hello world"</span>
</code></pre>
</div>
<p>That’s some strange syntax, this weird double parenthesis. It looks wrong,
unnatural, unholy. Its dark magic. We’re getting somewhere. What’s occurring
here is <em>strange</em>. The result of <code class="highlighter-rouge">function_builder</code> isn’t a string, its a
function that returns a string. Function builder gives you a function that can
then be executed to give you a useful result. At first this seems really
useless, but there is a second, much more important part to this.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_n_factory</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">add_n</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">add_n</span>

<span class="n">add_4</span> <span class="o">=</span> <span class="n">add_n_factory</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">add_4</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span>

<span class="n">add_6</span> <span class="o">=</span> <span class="n">add_n_factory</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">add_6</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span>

<span class="c"># for more weird syntax:</span>
<span class="k">assert</span> <span class="n">add_n_factory</span><span class="p">(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>
</code></pre>
</div>
<p>Here we take advantage of something called a
<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closure</a>. In
computer science, a closure is the idea of a computation bound to its
environment. This goes along with the idea of scope. A function can see what is
inside of it.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># global scope</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">pass</span>
    <span class="c"># inner scope, I can see 'x'</span>
<span class="c"># back to the global scope</span>
<span class="n">func</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c"># this will fail because x isn't defined in this scope</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>
</code></pre>
</div>

<p>But with nested functions, the inner functions have access to the variables in
the scope of the outer functions, as we could see with <code class="highlighter-rouge">add_n_factory</code>. The
newly created functions could access the value of n. What variables the
innermost function can see is defined by a set of scoping rules, generally
speaking a function can access anything in its scope or any enclosing scope
(this include the global scope) and in the case of conflicts the most specific
value (which is also the most recently defined) is used.</p>

<p>Its vital to note that the inner function is bound to the values used when
defining that function, thus if you run <code class="highlighter-rouge">add_n_factory</code> again later, it won’t
change the value of n in a previously created scoped function. In other words,
you can’t mutate a previously created inner function.</p>

<p>So we have a few ideas ideas:</p>

<ol>
  <li>you can pass a function into another function</li>
  <li>we can dynamically construct a new function within a function</li>
  <li>we can bind a dynamically built function to some values in a closure</li>
</ol>

<p>Combining them all leads to a decorator.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decorate_add_one_more</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">add_one_more</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">add_one_more</span>

<span class="n">add_5</span> <span class="o">=</span> <span class="n">decorate_add_one_more</span><span class="p">(</span><span class="n">add_4</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">add_5</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">15</span>

<span class="c"># and for more syntactical shenanigans</span>
<span class="k">assert</span> <span class="n">decorate_add_one_more</span><span class="p">(</span><span class="n">add_n_factory</span><span class="p">(</span><span class="mi">5</span><span class="p">))(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">9</span>
</code></pre>
</div>

<p>This merits an explanation. <code class="highlighter-rouge">decorate_add_one_more</code> is a function. You pass a
function into it, and it returns a different function. The function you give it
should ideally take in and return an integer, otherwise weird things might
happen. That function is then bound to a new function, <code class="highlighter-rouge">add_one_more</code> and
<code class="highlighter-rouge">add_one_more</code> calls the old function, does some additional processing and
returns a different value. This is the basic idea of a decorator.</p>

<p>Importantly though, python provides some very special syntax for decorators. Its
common to want to immediately decorate a function in some manner. Often when
using a library, the designers will have done something to abstract away a set
of processing, and the library’s API will involve decorators to keep the
abstractions clean (see Flask). Other times, a decorator can be used to modify a
function to provide a common functionality (such as <code class="highlighter-rouge">staticmethod</code>, <code class="highlighter-rouge">lru_cache</code>
and family from the standard library). In such cases, there is a common pattern
to immediately define a function and then decorate it, python provides a syntax
for this using the @ symbol.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_7</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">x</span>

<span class="n">add_7</span> <span class="o">=</span> <span class="n">decorate_add_one_more</span><span class="p">(</span><span class="n">add_7</span><span class="p">)</span>

<span class="nd">@decorate_add_one_more</span>
<span class="k">def</span> <span class="nf">add_9</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">x</span>

<span class="k">assert</span> <span class="n">add_7</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">add_9</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">9</span>  <span class="c"># it works!</span>
</code></pre>
</div>

<p>The above two methods are implemented in essentially the same way. A function is
defined and immediately passed into another function, which modifies it and
returns a new function under the name of the old function. That means that the
versions that adds 8 is never really accessible (it is if you try really hard,
but that’s another post). And the version that adds 6 is only accessible until
it is wrapped a few lines later. After that, the “old” functions essentially
disappear and its only possible to work with the wrapped function. The result
being that the function works “correctly” is the only accessible one.</p>

<p>So that’s how decorators work. There are a few more complex topics to cover. The
first is decorators that take arguments. As an example, in flask, you use
<code class="highlighter-rouge">@app.route('/')</code> to denote the url at which a certain page will be accessible.
This isn’t the same kind of decorator as what we were using. Instead, we need to
create a decorator factory.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">do_nothing</span><span class="p">(</span><span class="n">f</span><span class="p">):</span> <span class="c"># a decorator</span>
    <span class="k">return</span> <span class="n">f</span>

<span class="k">def</span> <span class="nf">do_nothing_wrapper</span><span class="p">():</span> <span class="c"># a decorator factory</span>
    <span class="k">def</span> <span class="nf">do_nothing_2</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span>
    <span class="k">return</span> <span class="n">do_nothing_2</span>

<span class="nd">@do_nothing</span>  <span class="c"># do nothing is called on func</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">10</span>

<span class="nd">@do_nothing_wrapper</span><span class="p">()</span>  <span class="c"># the result of do_nothing_wrapper is called on func</span>
<span class="k">def</span> <span class="nf">func_2</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">10</span>

<span class="k">assert</span> <span class="n">func</span><span class="p">()</span> <span class="o">==</span> <span class="mi">10</span>
<span class="k">assert</span> <span class="n">func_2</span><span class="p">()</span> <span class="o">==</span> <span class="mi">10</span>
</code></pre>
</div>

<p>In essence, the result of the @ line is what is called on the function, so once
you evaluate what follow @, you should have a function that is then called on
the decorated function. This is still mind bending and leads to some convoluted
code.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_n_more</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">add_n_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">new_adder</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">new_adder</span>
    <span class="k">return</span> <span class="n">add_n_decorator</span>

<span class="nd">@add_n_more</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add_15</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">12</span>

<span class="nd">@add_n_more</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add_3</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span>  <span class="c"># I was running out of numbers</span>


<span class="k">assert</span> <span class="n">add_3</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span>
<span class="k">assert</span> <span class="n">add_15</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">20</span>
<span class="c"># now for some horrors</span>
<span class="c"># I'm going to use lambdas for simplicities sake, hopefully you are familiar</span>
<span class="k">assert</span> <span class="n">add_n_more</span><span class="p">(</span><span class="mi">3</span><span class="p">)(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)(</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span>
</code></pre>
</div>

<p>Here, add_n_more constructs a new decorator at runtime, which then wraps the
function that is defined. This decorator then adds the value that is passed to
the function factory, instead of a predefined value. That said, its still a
terrifying layering of functions 3 deep.</p>

<p>The second more complex idea is that of generic decorators using variable length
arguments and variable length keyword arguments. Quickly, lets define a sum
function in two ways, one with and one without keyword arguments</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_sum</span><span class="p">(</span><span class="n">a_list</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">a_list</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">item</span>
    <span class="k">return</span> <span class="n">s</span>

<span class="k">def</span> <span class="nf">my_var_sum</span><span class="p">(</span><span class="o">*</span><span class="n">a_list</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">a_list</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">item</span>
    <span class="k">return</span> <span class="n">s</span>
</code></pre>
</div>

<p>These are…exactly the same, with the exception of an asterisk in the second
one. So now lets test them.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">assert</span> <span class="n">my_sum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span> <span class="o">==</span> <span class="mi">10</span>
<span class="k">assert</span> <span class="n">my_var_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span>
<span class="k">assert</span> <span class="n">my_var_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="mi">45</span>
</code></pre>
</div>
<p>Here the difference becomes apparent. With the <code class="highlighter-rouge">*a_list</code> syntax, you don’t pass
in the list, you pass in a series of single values. Python then forms these into
a variable length list which can be accessed from the variable name preceded by
an asterisk. Normally, this variable is named <code class="highlighter-rouge">*args</code>. Similarly, for keyword
arguments, <code class="highlighter-rouge">**kwargs</code> can be used to form a variable sized dictionary of keyword
arguments.</p>

<p>Further, there is a syntax for unpcking such lists, called either the splat or
“unpacking argument lists” operator, using <code class="highlighter-rouge">*list</code> or <code class="highlighter-rouge">**dict</code> will unpack them
into component arguments. This syntax only works within a function call.</p>

<p>Putting these together, we can create generic decorators that work on any
function with any set of arguments.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dynamic_logging_decorator</span><span class="p">(</span><span class="nb">file</span><span class="o">=</span><span class="s">"out.log"</span><span class="p">):</span>
    <span class="c"># lets use a decorator that can optionally take an argument</span>
    <span class="k">def</span> <span class="nf">debug_decorator</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">decorated_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="s">'a'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">"calling function "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">function</span><span class="p">)</span> <span class="o">+</span>
                <span class="s">" with args "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="s">"; and keyword args "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">decorated_function</span>
    <span class="k">return</span> <span class="n">debug_decorator</span>
</code></pre>
</div>

<p>I leave testing this as an exercise to the reader.</p>

<p>That’s a wrap for my introductory post, hope you enjoyed it. I’m always looking
for feedback though you can’t comment here. <a href="https://github.com/joshuamorton/joshuamorton.github.com/blob/master/_blogscripts/2015-9-27-decorators.py">Here’s</a> the link to the “inverted” version
    of this that should be a valid python 3.x file, and <a href="https://github.com/joshuamorton/joshuamorton.github.com/blob/master/_posts/2015-9-27-decorators.md">here’s</a> the link to the post source.</p>

<p>There may be some python errors in this, but the code in the source file is all
correct.</p>


  </section>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="5.html">Older</a>
  
  
    
      <a class="pagination-item newer" href="3.html">Newer</a>
    
  
</div>



              </div>
          </div>

          <!-- Sidebar -->
  <div id="sidebar">
    <div class="inner">


      <!-- Menu -->
        <nav id="menu">
          <ul>
            <li><a href="../../index.html">Homepage</a></li>
            <li><a href="../../contact.html">Contact Me</a></li>
            <li><a href="../../experience.1.html">Experience</a></li>
            <li><a href="../../involvement.1.html">Involvement</a></li>
            <li><a href="../../projects.1.html">Projects</a></li>
          </ul>
        </nav>


      <!-- Section -->
        <section>
          <header class="major">
              <a href="../../blog.1.html"><h2>Blog</h2></a>
          </header>
          <nav id='menu'>
              <ul>
                
                <li><a href="../../2017/01/25/juggling/index.html">What is an Average Juggle?</a></li>
                
                <li><a href="../../2015/11/06/lambda-calculus/index.html">Lambda Calculus</a></li>
                
                <li><a href="../../2015/10/04/types/index.html">Writing a Type System</a></li>
                
                <li><a href="../../2015/09/27/decorators/index.html">Decorators</a></li>
                
                <li><a href="../../2015/09/20/welcome-to-parseltongue/index.html">Welcome</a></li>
                   
              </ul>
          </nav>
        </section>

      <!-- Footer -->
        <footer id="footer">
          <p class="copyright">&copy; Joshua Morton. All rights reserved. Design: <a href="https://html5up.net">HTML5 UP</a>. Jekyll integration: <a href="https://andrewbanchi.ch">Andrew Banchich</a>.</p>
        </footer>

    </div>
  </div>


      </div>

      <!-- Scripts -->
  <script src="../../assets/js/jquery.min.js"></script>
  <script src="../../assets/js/skel.min.js"></script>
  <script src="../../assets/js/util.js"></script>
  <!--[if lte IE 8]><script src="https://joshuamorton.github.io/assets/js/ie/respond.min.js"></script><![endif]-->
  <script src="../../assets/js/main.js"></script>


</body>

</html>
